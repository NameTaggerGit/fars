# FARS Messenger — Архитектура

## 1. Общая концепция

Браузерный мессенджер с раздельным frontend и backend, готовый к масштабированию и использованию API мобильными клиентами.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           КЛИЕНТЫ                                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  (будущее: мобильные) │
│  │ Web (React) │  │   Планшет   │  │   Телефон   │                       │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘                       │
└─────────┼────────────────┼────────────────┼──────────────────────────────┘
          │                │                │
          ▼                ▼                ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        API GATEWAY / REVERSE PROXY                        │
│                    (Nginx / Traefik / Cloudflare)                         │
└─────────────────────────────────────────────────────────────────────────┘
          │
          ├──────────────────┬──────────────────┬──────────────────┐
          ▼                  ▼                  ▼                  ▼
┌──────────────┐   ┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│  REST API    │   │  WebSocket   │   │  WebRTC      │   │  Static /    │
│  (NestJS)    │   │  (Socket.io) │   │  (Signaling) │   │  Uploads     │
└──────┬───────┘   └──────┬───────┘   └──────┬───────┘   └──────┬───────┘
       │                  │                  │                  │
       └──────────────────┼──────────────────┘                  │
                          ▼                                      ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         СЛОЙ ДАННЫХ                                       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  PostgreSQL  │  │    Redis     │  │  S3 / MinIO  │  │   (опц.)     │  │
│  │  (основная   │  │  (сессии,   │  │  (файлы,     │  │   Elastic    │  │
│  │   БД)        │  │   кэш, pub/ │  │   аватарки)  │  │   Search     │  │
│  │              │  │   sub)       │  │              │  │              │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 2. Технологический стек

### Frontend
| Технология | Назначение |
|------------|------------|
| **React 18** | UI, компоненты |
| **TypeScript** | Типизация |
| **Vite** | Сборка, HMR (быстрее CRA, проще Next для SPA мессенджера) |
| **TailwindCSS** | Стили, утилиты, responsive |
| **Zustand** | Глобальное состояние (легче Redux, достаточно для чатов) |
| **React Query (TanStack Query)** | Кэш API, синхронизация, офлайн-готовность |
| **Framer Motion** | Анимации (появление, переходы) |
| **Socket.io-client** | Real-time события (сообщения, онлайн, типинг) |
| **simple-peer / PeerJS** | WebRTC для звонков (обёртка над native WebRTC) |
| **React Router v6** | Маршрутизация |

*Почему Vite, а не Next.js:* для мессенджера важна одна долгоживущая сессия и WebSocket; Next подойдёт, если позже понадобится SSR/SEO. Для закрытого мессенджера SPA на Vite проще и быстрее.

### Backend
| Технология | Назначение |
|------------|------------|
| **Node.js** | Runtime |
| **NestJS** | REST API, модули, DI, готовые интеграции (JWT, WebSocket, Prisma) |
| **TypeScript** | Типизация |
| **Prisma** | ORM, миграции, типы из схемы |
| **PostgreSQL** | Основная БД (пользователи, чаты, сообщения) |
| **Redis** | Сессии refresh-токенов, онлайн-статусы, pub/sub для WebSocket |
| **JWT** | Access token (короткий срок) |
| **Refresh tokens** | Хранение в БД или Redis, ротация |
| **Socket.io** | WebSocket-сервер (совместимость с клиентом) |
| **Multer + S3/MinIO** | Загрузка файлов и хранение |
| **Nodemailer** | Письма (подтверждение email, сброс пароля) |

### Инфраструктура и деплой
| Технология | Назначение |
|------------|------------|
| **Docker** | Контейнеризация API, WS, Redis, PostgreSQL |
| **docker-compose** | Локальная и staging-среда |
| **env переменные** | Конфигурация (`.env.example` в репозитории) |

---

## 3. Принципы архитектуры

- **Разделение frontend / backend** — два отдельных репозитория или монорепо с папками `apps/web`, `apps/api`.
- **API-first** — весь функционал доступен через REST + WebSocket; мобильное приложение будет использовать тот же API.
- **Чистая архитектура на backend** — слои: Controller → Service → Repository (Prisma). DTO и валидация (class-validator).
- **Роли и whitelist** — роли `user` | `moderator` | `admin`; доступ в админку только по whitelist (отдельная таблица или флаг).
- **Масштабирование** — несколько инстансов API за балансировщиком; один или несколько инстансов Socket.io с Redis adapter (sticky session или Redis pub/sub).

---

## 4. Стратегия масштабирования

1. **Горизонтальное масштабирование API** — stateless REST; за Nginx/Traefik несколько реплик NestJS.
2. **WebSocket** — Socket.io с [Redis Adapter](https://socket.io/docs/v4/redis-adapter/): события между инстансами через Redis pub/sub.
3. **База данных** — при росте: read replicas PostgreSQL, пул соединений (PgBouncer).
4. **Файлы** — объектное хранилище (S3-совместимое), CDN для раздачи.
5. **Кэширование** — Redis для частых запросов (профили, список чатов), инвалидация по событиям.

---

## 5. Безопасность

- **HTTPS** — обязательно в production.
- **CORS** — только доверенные домены фронта.
- **JWT** — короткий access (15–30 мин), refresh в httpOnly cookie или отдельный endpoint с ротацией.
- **Rate limiting** — на логин, регистрацию, восстановление пароля (например, express-rate-limit или Nest Throttler).
- **Валидация** — все входящие данные (DTO + class-validator).
- **Роли** — Guards в NestJS по ролям; админ-панель только для whitelist.

---

## 6. Подготовка к деплою

- Конфигурация через **переменные окружения** (не секреты в коде).
- **Health-check** endpoint (`/api/health`) для оркестратора и мониторинга.
- **Логирование** — структурированные логи (например, Pino); опционально сбор в Loki/ELK.
- **Мониторинг** — метрики (опционально Prometheus), uptime — по health и логам ошибок.
- **Миграции** — запуск Prisma migrate при старте или отдельным job в CI/CD.

Дальше: **структура проекта** (папки frontend и backend).
